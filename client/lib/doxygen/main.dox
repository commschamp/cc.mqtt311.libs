/// @mainpage MQTT v3.1.1 Client Library
/// @tableofcontents
/// @section doc_cc_mqtt311_client_overview Overview
/// The <b>MQTT v3.1.1 Client Library</b> from the <a href="https://commschamp.github.io/">CommsChampion Ecosystem</a>
/// provides simple, asynchronous, non-blocking,
/// and easy to use interface to operate MQTT v3.1.1 client. The library doesn't
/// make any assumption on the system it is running on, as well as on the type
/// of I/O link being used to communicate its data to the MQTT v3.1.1 capable broker.
///
/// It is a responsibility of the calling application to manage network connectivity
/// as well as measure time required for the correct operation of the MQTT v3.1.1 protocol.
///
/// The library allows the application to have a full control over the raw data for
/// any extra analysis and/or manipulation, such as encryption or extra framing.
///
/// @section doc_cc_mqtt311_client_version Version of the Library
/// The version is of the library applicable to this documentation is defined in
/// the @ref common.h "cc_mqtt311_client/common.h" file using the following defines:
/// @li @ref CC_MQTT311_CLIENT_MAJOR_VERSION
/// @li @ref CC_MQTT311_CLIENT_MINOR_VERSION
/// @li @ref CC_MQTT311_CLIENT_PATCH_VERSION
///
/// @section cc_mqtt311_client_header Header
/// To use this <b>MQTT v3.1.1 Client Library</b> use the following single include statement:
/// @code
/// #include "cc_mqtt311_client/client.h"
/// @endcode
///
/// @section doc_cc_mqtt311_client_allocation Client Allocation
/// The library supports multiple independent MQTT v3.1.1 client sessions. The
/// allocation of data structures relevant to a single client is performed
/// using cc_mqtt311_client_alloc() function.
/// @code
/// CC_Mqtt311ClientHandle client = cc_mqtt311_client_alloc();
/// @endcode
/// All other functions are client specific, they receive the returned handle
/// as their first parameter.
///
/// When work with allocated client is complete, it must be freed using
/// cc_mqtt311_client_free() function.
/// @code
/// cc_mqtt311_client_free(client);
/// @endcode
///
/// When working with C++ it is advised to use a smart pointer with a custom deleter.
/// @code
/// struct MyDeleter
/// {
///     void operator()(CC_Mqtt311Client* ptr)
///     {
///         ::cc_mqtt311_client_free(ptr);
///     }
/// };
///
/// using MyClientPtr = std::unique_ptr<CC_Mqtt311Client, MyDeleter>;
///
/// MyClientPtr clientPtr(::cc_mqtt311_client_alloc());
/// CC_Mqtt311ClientHandle client = clientPtr.get();
/// @endcode
///
/// @b IMPORTANT: The function @b cc_mqtt311_client_free() must @b NOT
/// be called from within a callback. Use next event loop iteration.
///
/// @section doc_cc_mqtt311_client_callbacks "Must Have" Callbacks Registration
/// In order to properly function the library requires setting several callbacks.
///
/// @subsection doc_cc_mqtt311_client_callbacks_send_data Sending Data To Broker
/// To client application must assign a callback for the library to be able to send
/// binary data out to the connected broker.
/// @code
/// void my_send_data_cb(void* data, const unsigned char* buf, unsigned bufLen)
/// {
///     ... /* send requested buffer to the broker */
/// }
///
/// cc_mqtt311_client_set_send_output_data_callback(client, &my_send_data_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt311SendOutputDataCb callback function definition.
///
/// In the invoked callback the application is responsible to send the provided data
/// over the I/O link. The application can also perform extra data manipulation like
/// encryption.
///
/// The reported data resides in internal data structures of the client library,
/// which can be updated / deleted right after the callback function returns.
/// It means the data may need to be copied into some other buffer, which will be
/// held intact until the send over I/O link operation is complete.
///
/// @subsection doc_cc_mqtt311_client_callbacks_broker_disconnect Reporting Unsolicited Broker Disconnection
/// The client application must assign a callback for the library to report
/// discovered broker disconnection.
/// @code
/// void my_broker_disconnected_cb(void* data, CC_Mqtt311BrokerDisconnectReason reason)
/// {
///     ... /* handle broker disconnection */
///     if (info != NULL) {
///         ... /* Access disconnection report details */
///     }
/// }
///
/// cc_mqtt311_client_set_broker_disconnect_report_callback(client, &my_broker_disconnected_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt311BrokerDisconnectReportCb callback function definition.
///
/// See also @ref doc_cc_mqtt311_client_unsolicited_disconnect
/// below for details.
///
/// @subsection doc_cc_mqtt311_client_callbacks_message Reporting Received Message
/// The client application must assign a callback for the library to report
/// application level messages received from the broker.
/// @code
/// void my_message_received_cb(void* data, const CC_Mqtt311MessageInfo* info)
/// {
///     ... /* handle the received message */
/// }
///
/// cc_mqtt311_client_set_message_received_report_callback(client, &my_message_received_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt311MessageReceivedReportCb callback function definition.
///
/// @section doc_cc_mqtt311_client_time Time Measurement
/// For the correct operation of the MQTT v3.1.1 client side of the protocol, the library
/// requires an ability to measure time. This responsibility is delegated to the
/// application.
///
/// The easiest (although not very efficient or very precise) method is to periodically (say every 20ms - 50ms)
/// call the @b cc_mqtt311_client_tick() function reporting the amount of elapsed milliseconds:
/// @code
/// cc_mqtt311_client_tick(client, 50U);
/// @endcode
/// The library will check if some inner timer has expired and may initiate some
/// response via invocation one of the registered callbacks.
///
/// Another (recommended) method is to register a callback so the library
/// may request the time measurement from the application, and when the
/// requested time expires, the application is expected to call the
/// @b cc_mqtt311_client_tick() function reporting amount of elapsed milliseconds.
/// @code
/// void my_tick_program_cb(void* data, unsigned ms)
/// {
///     ... // program appropriate timer
/// }
///
/// cc_mqtt311_client_set_next_tick_program_callback(client, &my_tick_program_cb, data);
/// @endcode
/// It is allowed to invoke the @b cc_mqtt311_client_tick() before the actual requested timeout has
/// expired, just make sure that the correct amount of elapsed milliseconds is reported. When
/// the @b cc_mqtt311_client_tick() is invoked, it is assumed that the previously requested tick
/// programming has been cancelled and the registered callback requesting to re-program
/// the timer may be invoked again from within the
/// @b cc_mqtt311_client_tick().
///
/// See also the documentation of the @ref CC_Mqtt311NextTickProgramCb callback function definition.
///
/// In case of callback approach for time measurement is chosen, another callback function
/// (in addition to requesting the new timer programming) to
/// allow interruption of the previously programmed timer must also to be registered.
/// @code
/// unsigned my_cancel_tick_program_cb(void* data)
/// {
///     ...
///     return ... /* return amount of elapsed milliseconds since last tick program */
/// }
///
/// cc_mqtt311_client_set_cancel_next_tick_wait_callback(client, &my_cancel_tick_program_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt311CancelNextTickWaitCb callback function definition.
///
/// Usually the callbacks of canceling the previously programmed tick and programming a new one
/// will be invoked as a side effect of other events, like report of the incoming data or
/// client requesting to perform one of the available operations.
///
/// @section doc_cc_mqtt311_client_log Error Logging
/// Sometimes the library may exhibit unexpected behaviour, like rejecting some of the parameters.
/// To allow getting extra guidance information of what went wrong it is possible to register
/// optional error logging callback.
/// @code
/// void my_error_log_cb(void* data, const char* msg)
/// {
///     printf("ERROR: %s\n", msg);
/// }
///
/// cc_mqtt311_client_set_error_log_callback(client, &my_error_log_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt311ErrorLogCb callback function definition.
///
/// @section doc_cc_mqtt311_client_data Reporting Incoming Data
/// It is the responsibility of the application to receive data from the broker
/// and report it to the library. The report is performed using the
/// @b cc_mqtt311_client_process_data() function.
/// @code
/// uint8_t buf[MAX_BUF_SIZE];
/// ... // Receive data into buffer
/// unsigned bufLen = ...; // Amount of received bytes in the buffer.
/// unsigned consumed = cc_mqtt311_client_process_data(client, buf, bufLen);
/// ... // Remove the first "consumed" bytes from the buffer and retain the rest
///     // until the new data chunk arrives.
/// @endcode
/// The application is responsible to maintain the input buffer. The
/// value returned from the @b cc_mqtt311_client_process_data() function reports
/// amount of consumed bytes. In case not all of the reported bytes were consumed
/// the application is responsible to keep them and report again with new appended
/// data when such arrives.
///
/// When new data chunk is reported the library may invoke several callbacks,
/// such as reporting received message, sending new data out, as well as canceling
/// the old and programming new tick timeout.
///
/// @section doc_cc_mqtt311_client_concepts Operating Concepts
/// The library abstracts away multiple MQTT v3.1.1 protocol based "operations". Every such operation
/// has multiple stages:
/// @li @b prepare - The operation is "allocated" and relevant handle is returned.
/// @li @b configure - Apply one or multiple configurations to the prepared operation.
/// @li @b send - Send the configured operation message to the broker.
///
/// During the @b send stage the application is expected to provide the callback to
/// report to the application when the operation is complete. One of the parameters
/// of the callback is always "status" of the @ref CC_Mqtt311AsyncOpStatus type. It
/// indicates whether the operation was successfully complete. In addition to the
/// status it reports some extra information reported by the broker. The information
/// from the broker is available <b>if and only if</b> the status is
/// @ref CC_Mqtt311AsyncOpStatus_Complete.
///
/// The @b send stage function also returns @ref CC_Mqtt311ErrorCode value to indicate
/// whether the @b send was successfully performed. The provided callback will
/// be invoked <b>if and only if</b> the @b send returns @ref CC_Mqtt311ErrorCode_Success.
///
/// After the @b send stage the handle returned in the @b prepare stage can be discarded
/// (no explicit de-allocation is needed / supported) regardless of the return code.
/// After successful @b send the handle still remains valid until the callback invocation and can be used
/// to @b cancel the operation. Note that in case the appropriate message has already be
/// @b sent to the broker, cancelling the outstanding operation can be dangerous. When
/// broker sends a response and client is not expecting it any more, unexpected
/// behaviour (like treating the unexpected message as "protocol error" and disconnecting
/// from the broker) may happen.
///
/// In case something went wrong during the @b configure stage, it is possible to de-allocate
/// the prepared operation using the @b cancel request. After performing the @b cancel
/// stage the allocated handle is no longer valid.
///
/// <b>IMPORTANT LIBRARY LIMITATION</b>: Once an operation is @b prepared,
/// it must be be immediately @b configured and @b sent (or @b cancelled) before
/// any other other operation can be @b prepared. For example:
/// @code
/// CC_Mqtt311ErrorCode ec = CC_Mqtt311ErrorCode_Success;
/// CC_Mqtt311ConnectHandle connect = cc_mqtt311_client_connect_prepare(...);
/// assert(connect != nullptr);
///
/// // The following attempt to prepare the "subscribe" operation will fail because
/// // previously allocated "connect" hasn't been sent or cancelled yet.
/// CC_Mqtt311SubscribeHandle subscribe = cc_mqtt311_client_subscribe_prepare(...);
/// assert(subscribe == NULL);
/// @endcode
///
/// @section doc_cc_mqtt311_client_response_timeout Default Response Timeout
/// After sending any operation request to the broker, the client library has to allow
/// some time for the broker to process the request. If it takes too much time, the
/// client must report that operation has failed via the set callback. By default the client
/// library allows 2 seconds for such response to arrive. Changing this default value
/// is possible using the @b cc_mqtt311_client_set_default_response_timeout() function,
/// and retrieving of the currently configured value can be done using the
/// @b cc_mqtt311_client_get_default_response_timeout() function.
/// @code
/// CC_Mqtt311ErrorCode ec = cc_mqtt311_client_set_default_response_timeout(client, 3000 /* in ms */);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
///
/// @section doc_cc_mqtt311_client_connect Connecting to Broker
/// To connect to broker use @ref connect "connect" operation.
///
/// @subsection doc_cc_mqtt311_client_connect_prepare Preparing "Connect" Operation.
/// @code
/// CC_Mqtt311ErrorCode ec = CC_Mqtt311ErrorCode_Success;
/// CC_Mqtt311ConnectHandle connect = cc_mqtt311_client_connect_prepare(client, &ec);
/// if (connect == NULL) {
///     printf("ERROR: Connect allocation failed with ec=%d\n", ec);
/// }
/// @endcode
/// @b NOTE that the @b cc_mqtt311_client_connect_prepare() cannot be called from within a callback.
/// For example, if the broker disconnection is reported via @ref doc_cc_mqtt311_client_callbacks_broker_disconnect "callback"
/// then the @b cc_mqtt311_client_connect_prepare() cannot be invoked right away.
/// It needs to be postponed until the next event loop iteration.
///
/// @subsection doc_cc_mqtt311_client_connect_response_timeout Configuring "Connect" Response Timeout
/// When created, the "connect" operation inherits the @ref doc_cc_mqtt311_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt311_client_connect_set_response_timeout() function.
/// @code
/// ec = cc_mqtt311_client_connect_set_response_timeout(connect, 1000);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt311_client_connect_get_response_timeout() function.
///
/// @subsection doc_cc_mqtt311_client_connect_basic Configuration of "Connect" Operation
/// To configure "connect" operation use @b cc_mqtt311_client_connect_config() function.
/// @code
/// CC_Mqtt311ConnectConfig config;
///
/// // Assign default values to the "config"
/// cc_mqtt311_client_connect_init_config(&config);
///
/// // Update the values if needed:
/// config.m_clientId = "some_client";
/// config.m_cleanSession = true;
///
/// // Perform the configuration
/// ec = cc_mqtt311_client_connect_config(connect, &config);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Basic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// **IMPORTANT**: MQTT v3.1.1 specification allows reconnection to the broker while
/// requesting previous session restoration (via "clean session" bit). By default,
/// the client library verifies that the message received from the broker was
/// actually subscribed to before reporting the message to the application
/// (see @ref doc_cc_mqtt311_client_receive for details). To prevent
/// potential errors of the client and broker inner states being out of sync, the
/// @b first "connect" operation requires setting the @ref CC_Mqtt311ConnectConfig::m_cleanSession
/// value to @b true. The only exception to this rule is when the subscription
/// verification on message reception was disabled (described in the
/// @ref doc_cc_mqtt311_client_receive section below). In case the subscription
/// verification is still enabled and the @ref CC_Mqtt311ConnectConfig::m_cleanSession
/// value is @b NOT set to @b true, the function rejects the configuration
/// with the @ref CC_Mqtt311ErrorCode_BadParam error code. Any subsequent reconnection attempts will allow
/// setting the value to @b false.
///
/// See also documentation of the @ref CC_Mqtt311ConnectConfig structure.
///
/// @subsection doc_cc_mqtt311_client_connect_will Will Configuration
/// To perform will configuration use the @b cc_mqtt311_client_connect_config_will() function.
/// @code
/// CC_Mqtt311ConnectWillConfig willConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt311_client_connect_init_config_will(&willConfig);
///
/// // Update values if needed
/// willConfig.m_topic = "some/topic";
/// willConfig.m_data = ...;
/// willConfig.m_dataLen = ...;
/// ...
///
/// // Perform the configuration
/// ec = cc_mqtt311_client_connect_config_will(connect, &willConfig);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Will configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt311ConnectWillConfig structure.
///
/// @subsection doc_cc_mqtt311_client_connect_send Sending Connection Request
/// When all the necessary configurations are performed for the allocated "connect"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt311_client_connect_send() function.
/// @code
/// void my_connect_complete_cb(void* data, CC_Mqtt311AsyncOpStatus status, const CC_Mqtt311ConnectResponse* response)
/// {
///     if (status != CC_Mqtt311AsyncOpStatus_Complete) {
///         printf("ERROR: The connection operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt311AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt311_client_connect_send(connect, &my_connect_complete_cb, data);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send connect request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "connect" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt311ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt311_client_connect_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt311_client_connect_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt311ErrorCode_Success was returned).
/// The valid handle can be used to @ref doc_cc_mqtt311_client_connect_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// When the "connect" operation completion callback is invoked the reported
/// "response" information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt311AsyncOpStatus_Complete.
///
/// @b NOTE that only single "connect" operation is allowed at a time, any attempt to
/// prepare a new one via @b cc_mqtt311_client_connect_prepare() will be rejected
/// until the "connect" operation completion callback is invoked or
/// the operation is @ref doc_cc_mqtt311_client_connect_cancel "cancelled".
///
/// Quote from the MQTT v3.1.1 specification:
/// @code{.unparsed}
/// If a server sends a CONNACK packet containing a non-zero return code it MUST
/// then close the Network Connection [MQTT-3.2.2-5].
/// @endcode
/// When the callback reporting the connection status is invoked, it is responsibility
/// of the application to check the @ref CC_Mqtt311ConnectResponse::m_returnCode value.
/// If it's not @ref CC_Mqtt311ConnectReturnCode_Accepted, the application
/// is responsible to close the network connection and retry the "connect" operation after
/// the network connection to the broker is re-established. The same should be
/// done when the "connect" operation is not properly completed, i.e. the
/// reported status is @b NOT @ref CC_Mqtt311AsyncOpStatus_Complete.
///
/// @subsection doc_cc_mqtt311_client_connect_cancel Cancel the "Connect" Operation.
/// While the handle returned by the @b cc_mqtt311_client_connect_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt311_client_connect_cancel(connect);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to cancel connect with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt311_client_connect_send() function was successfully
/// called before the @b cc_mqtt311_client_connect_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @subsection doc_cc_mqtt311_client_connect_simplify Simplifying the "Connect" Operation Preparation.
/// In many use cases the "connect" operation can be quite simple with a lot of defaults.
/// To simplify the sequence of the operation preparation and handling of errors,
/// the library provides wrapper function(s) that can be used:
/// @li @b cc_mqtt311_client_connect()
///
/// For example:
/// @code
/// CC_Mqtt311ConnectConfig config;
///
/// // Assign default values to the "config"
/// cc_mqtt311_client_connect_init_config(&config);
///
/// // Update the values if needed:
/// config.m_clientId = "some_client";
/// config.m_cleanSession = true;
///
/// ec = cc_mqtt311_client_connect(client, config, null, &my_connect_complete_cb, data);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send connect request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// Note that the wrapper function does NOT expose the handle returned by the
/// @b cc_mqtt311_client_connect_prepare(). It means that it's not possible to
/// cancel the "connect" operation before its completion.
///
/// @subsection doc_cc_mqtt311_client_connect_check Check The Library Remains Connected
/// At any time it is possible to check the internal state of the library of
/// whether it's properly connected to the broker.
/// @code
/// bool isConnected = cc_mqtt311_client_is_connected(client);
/// @endcode
///
/// @section doc_cc_mqtt311_client_disconnect Disconnecting From Broker
/// To intentionally disconnect from broker use @ref disconnect "disconnect" operation. The
/// unsolicited disconnection from the broker is described in ref
/// @ref doc_cc_mqtt311_client_unsolicited_disconnect section below.
///
/// @subsection doc_cc_mqtt311_client_disconnect_prepare Preparing "Disconnect" Operation.
/// @code
/// CC_Mqtt311ErrorCode ec = CC_Mqtt311ErrorCode_Success;
/// CC_Mqtt311DisconnectHandle disconnect = cc_mqtt311_client_disconnect_prepare(client, &ec);
/// if (disconnect == NULL) {
///     printf("ERROR: Disconnect allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection doc_cc_mqtt311_client_disconnect_send Sending Disconnection Request
/// When the necessary configuration is performed for the allocated "disconnect"
/// operation it can be sent to the broker. To initiate sending
/// use the @b cc_mqtt311_client_disconnect_send() function.
/// @code
/// ec = cc_mqtt311_client_disconnect_send(disconnect);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send disconnect request with ec=%d\n", ec);
///     ...
///     return;
/// }
/// assert(!cc_mqtt311_client_is_connected(client)); // Expect immediate disconnection after the successful send
/// @endcode
/// @b NOTE that the @b cc_mqtt311_client_disconnect_send() function doesn't receive
/// any callback because there is no expected response to the @b DISCONNECT message
/// from the broker. The disconnection effect is immediate. The application is
/// expected to terminate the network connection (while making sure that the
/// the requested data is actually sent). The
/// handle returned by the @b cc_mqtt311_client_disconnect_prepare() must be discarded.
///
/// In case there are other asynchronous operations that hasn't been completed yet,
/// their completion callback is automatically invoked with @ref CC_Mqtt311AsyncOpStatus_Aborted
/// status.
///
/// @b IMPORTANT: In case of sending the explicit disconnection request the
/// @ref doc_cc_mqtt311_client_callbacks_broker_disconnect "registered unsolicited disconnection callback"
/// is @b NOT invoked.
///
/// After the disconnection the application can re-establish network connection
/// to the broker and perform the @ref doc_cc_mqtt311_client_connect "connect" operation
/// again.
///
/// @subsection doc_cc_mqtt311_client_disconnect_cancel Cancel the "Disconnect" Operation.
/// While the handle returned by the @b cc_mqtt311_client_disconnect_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt311_client_disconnect_cancel(disconnect);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to cancel disconnect with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// @subsection doc_cc_mqtt311_client_disconnect_simplify Simplifying the "Disonnect" Operation Preparation.
/// In many use cases the "disconnect" operation can be quite simple.
/// To simplify the sequence of the operation preparation and handling of errors,
/// the library provides wrapper function(s) that can be used:
/// @li @b cc_mqtt311_client_disconnect()
///
/// For example:
/// @code
/// ec = cc_mqtt311_client_disconnect(client);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send disconnect request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// @section doc_cc_mqtt311_client_subscribe Subscribing to Receive Messages
/// To subscribe to receive incoming messages use @ref subscribe "subscribe" operation.
/// The application can issue multiple "subscribe" operations in parallel.
///
/// @subsection doc_cc_mqtt311_client_subscribe_prepare Preparing "Subscribe" Operation.
/// @code
/// CC_Mqtt311ErrorCode ec = CC_Mqtt311ErrorCode_Success;
/// CC_Mqtt311SubscribeHandle subscribe = cc_mqtt311_client_subscribe_prepare(client, &ec);
/// if (subscribe == NULL) {
///     printf("ERROR: Subscribe allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection doc_cc_mqtt311_client_subscribe_response_timeout Configuring "Subscribe" Response Timeout
/// When created, the "subscribe" operation inherits the @ref doc_cc_mqtt311_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt311_client_subscribe_set_response_timeout() function.
/// @code
/// ec = cc_mqtt311_client_subscribe_set_response_timeout(subscribe, 1000);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt311_client_subscribe_get_response_timeout() function.
///
/// @subsection doc_cc_mqtt311_client_subscribe_topic Topic Configuration
/// Single @b SUBSCRIBE message can carry multiple topic subscriptions. Use
/// separate @b cc_mqtt311_client_subscribe_config_topic() function invocation to configure each
/// such subscription.
/// @code
/// CC_Mqtt311SubscribeTopicConfig topicConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt311_client_subscribe_init_config_topic(&topicConfig);
///
/// // Update values if needed
/// topicConfig.m_topic = "some/topic";
///
/// // Perform the configuration
/// ec = cc_mqtt311_client_subscribe_config_topic(subscribe, &topicConfig);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Topic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt311SubscribeTopicConfig structure.
///
/// By default the library will perform the analysis of the submitted topic format and
/// reject it if topic format is incorrect. However, for performance reasons
/// it is possible to disable such verification when client application
/// ensures that no invalid topics are used.
/// @code
/// ec = cc_mqtt311_client_set_verify_outgoing_topic_enabled(client, false);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something is wrong */
/// }
/// @endcode
/// @b NOTE that the configuration is global per client and not per "subscribe"
/// operation.
///
/// Also @b note that the same function controls the verification of the
/// "subscribe", "unsubscribe" and "publish" topic formats.
///
/// To retrieve the current configuration use @b cc_mqtt311_client_get_verify_outgoing_topic_enabled()
/// function.
///
/// @subsection doc_cc_mqtt311_client_subscribe_send Sending Subscription Request
/// When all the necessary configurations are performed for the allocated "subscribe"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt311_client_subscribe_send() function.
/// @code
/// void my_subscribe_complete_cb(void* data, CC_Mqtt311SubscribeHandle handle, CC_Mqtt311AsyncOpStatus status, const CC_Mqtt311SubscribeResponse* response)
/// {
///     if (status != CC_Mqtt311AsyncOpStatus_Complete) {
///         printf("ERROR: The subscription operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt311AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt311_client_subscribe_send(subscribe, &my_subscribe_complete_cb, data);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send subscribe request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "subscribe" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt311ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt311_client_subscribe_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt311_client_subscribe_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt311ErrorCode_Success was returned).
/// The valid handle can be used to @ref doc_cc_mqtt311_client_subscribe_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// Note that the callback function receives the "subscribe" operation handle as
/// its second parameter. Although the handle is already invalid and cannot be
/// used in any other function, it allows the application to identify the
/// original "subscribe" request if multiple have been issued in parallel
/// and use the same callback function for all of them.
///
/// When the "subscribe" operation completion callback is invoked the reported
/// "response" information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt311AsyncOpStatus_Complete.
///
/// @subsection doc_cc_mqtt311_client_subscribe_cancel Cancel the "Subscribe" Operation.
/// While the handle returned by the @b cc_mqtt311_client_subscribe_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt311_client_subscribe_cancel(subscribe);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to cancel subscribe with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt311_client_subscribe_send() function was successfully
/// called before the @b cc_mqtt311_client_subscribe_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @subsection doc_cc_mqtt311_client_subscribe_simplify Simplifying the "Subscribe" Operation Preparation.
/// In many use cases the "subscribe" operation can be quite simple with a lot of defaults.
/// To simplify the sequence of the operation preparation and handling of errors,
/// the library provides wrapper function that can be used:
/// @li @b cc_mqtt311_client_subscribe()
///
/// For example:
/// @code
/// CC_Mqtt311SubscribeTopicConfig topicConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt311_client_subscribe_init_config_topic(&topicConfig);
///
/// // Update values if needed
/// topicConfig.m_topic = "some/topic";
///
/// ec = cc_mqtt311_client_subscribe(client, &topicConfig, 1, &my_subscribe_complete_cb, data);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send subscribe request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// Note that the wrapper function does NOT expose the handle returned by the
/// @b cc_mqtt311_client_subscribe_prepare(). It means that it's not possible to
/// cancel the "subscribe" operation before its completion or identify the
/// subscribe operation by the reported handle when the completion callback
/// is invoked.
///
/// @section doc_cc_mqtt311_client_unsubscribe Unsubscribing from Message Reception
/// To unsubscribe from receiving incoming messages use @ref unsubscribe "unsubscribe" operation.
/// The application can issue multiple "unsubscribe" operations in parallel.
///
/// @subsection doc_cc_mqtt311_client_unsubscribe_prepare Preparing "Unsubscribe" Operation.
/// @code
/// CC_Mqtt311ErrorCode ec = CC_Mqtt311ErrorCode_Success;
/// CC_Mqtt311UnsubscribeHandle unsubscribe = cc_mqtt311_client_unsubscribe_prepare(client, &ec);
/// if (unsubscribe == NULL) {
///     printf("ERROR: Unsubscribe allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection doc_cc_mqtt311_client_unsubscribe_response_timeout Configuring "Unsubscribe" Response Timeout
/// When created, the "unsubscribe" operation inherits the @ref doc_cc_mqtt311_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt311_client_unsubscribe_set_response_timeout() function.
/// @code
/// ec = cc_mqtt311_client_unsubscribe_set_response_timeout(unsubscribe, 1000);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt311_client_unsubscribe_get_response_timeout() function.
///
/// @subsection doc_cc_mqtt311_client_unsubscribe_topic Topic Configuration
/// Single @b UNSUBSCRIBE message can carry multiple topic unsubscriptions. Use
/// @b cc_mqtt311_client_unsubscribe_config_topic() function to configure each
/// such unsubscription.
/// @code
/// CC_Mqtt311UnsubscribeTopicConfig topicConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt311_client_unsubscribe_init_config_topic(&topicConfig);
///
/// // Update values
/// topicConfig.m_topic = "some/topic";
///
/// // Perform the configuration
/// ec = cc_mqtt311_client_unsubscribe_config_topic(unsubscribe, &topicConfig);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Topic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt311UnsubscribeTopicConfig structure.
///
/// @b Note that explicitly initializing the @ref CC_Mqtt311UnsubscribeTopicConfig
/// configuration object is not really necessary, because it has only a single @ref CC_Mqtt311UnsubscribeTopicConfig::m_topic member,
/// which is going to be overwritten as part of the configuration. However, calling
/// the @b cc_mqtt311_client_unsubscribe_init_config_topic() is still recommended to make the
/// application's code future updates proof. Potentially the MQTT v3.1.1 specification and as the
/// result this library can be updated by adding new fields to the @ref
/// CC_Mqtt311UnsubscribeTopicConfig struct. Having the "unnecessary" call to the
/// @b cc_mqtt311_client_unsubscribe_init_config_topic() function makes sure
/// that newly added field gets initialized to the default value without
/// any need to update the application's code.
///
/// By default the library will perform the analysis of the submitted topic format and
/// reject it if topic format is incorrect. However, for performance reasons
/// it is possible to disable such verification when client application
/// ensures that no invalid topics are used.
/// @code
/// ec = cc_mqtt311_client_set_verify_outgoing_topic_enabled(client, false);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something is wrong */
/// }
/// @endcode
/// @b NOTE that the configuration is global per client and not per "unsubscribe"
/// operation.
///
/// Also @b note that the same function controls the verification of the
/// "subscribe", "unsubscribe" and "publish" topic formats.
///
/// To retrieve the current configuration use @b cc_mqtt311_client_get_verify_outgoing_topic_enabled()
/// function.
///
/// @subsection doc_cc_mqtt311_client_unsubscribe_send Sending Unsubscription Request
/// When all the necessary configurations are performed for the allocated "unsubscribe"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt311_client_unsubscribe_send() function.
/// @code
/// void my_unsubscribe_complete_cb(void* data, CC_Mqtt311UnsubscribeHandle handle, CC_Mqtt311AsyncOpStatus status)
/// {
///     if (status != CC_Mqtt311AsyncOpStatus_Complete) {
///         printf("ERROR: The unsubscription operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     ...
/// }
///
/// ec = cc_mqtt311_client_unsubscribe_send(unsubscribe, &my_unsubscribe_complete_cb, data);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send unsubscribe request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "unsubscribe" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt311ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt311_client_unsubscribe_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt311_client_unsubscribe_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt311ErrorCode_Success was returned).
/// The valid handle can be used to @ref doc_cc_mqtt311_client_unsubscribe_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// Note that the callback function receives the "unsubscribe" operation handle as
/// its second parameter. Although the handle is already invalid and cannot be
/// used in any other function, it allows the application to identify the
/// original "unsubscribe" request if multiple have been issued in parallel
/// and use the same callback function for all of them.
///
/// @subsection doc_cc_mqtt311_client_unsubscribe_cancel Cancel the "Unsubscribe" Operation.
/// While the handle returned by the @b cc_mqtt311_client_unsubscribe_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt311_client_unsubscribe_cancel(unsubscribe);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to cancel unsubscribe with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt311_client_unsubscribe_send() function was successfully
/// called before the @b cc_mqtt311_client_unsubscribe_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @subsection doc_cc_mqtt311_client_unsubscribe_simplify Simplifying the "Unsubscribe" Operation Preparation.
/// In many use cases the "unsubscribe" operation can be quite simple with a lot of defaults.
/// To simplify the sequence of the operation preparation and handling of errors,
/// the library provides wrapper function that can be used:
/// @li @b cc_mqtt311_client_unsubscribe()
///
/// For example:
/// @code
/// CC_Mqtt311UnsubscribeTopicConfig topicConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt311_client_unsubscribe_init_config_topic(&topicConfig);
///
/// // Update values
/// topicConfig.m_topic = "some/topic";
///
/// ec = cc_mqtt311_client_unsubscribe(client, &topicConfig, 1, &my_unsubscribe_complete_cb, data);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send unsubscribe request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// Note that the wrapper function does NOT expose the handle returned by the
/// @b cc_mqtt311_client_unsubscribe_prepare(). It means that it's not possible to
/// cancel the "unsubscribe" operation before its completion or identify the
/// unsubscribe operation by the reported handle when the completion callback
/// is invoked.
///
/// @section doc_cc_mqtt311_client_publish Publishing Messages
/// To publish messages to the broker use @ref publish "publish" operation.
///
/// @subsection doc_cc_mqtt311_client_publish_prepare Preparing "Publish" Operation.
/// @code
/// CC_Mqtt311ErrorCode ec = CC_Mqtt311ErrorCode_Success;
/// CC_Mqtt311PublishHandle publish = cc_mqtt311_client_publish_prepare(client, &ec);
/// if (publish == NULL) {
///     printf("ERROR: Publish allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection doc_cc_mqtt311_client_publish_response_timeout Configuring "Publish" Response Timeout
/// When publishing messages with QoS value @ref CC_Mqtt311QoS_AtLeastOnceDelivery or above, the
/// response from the broker is expected.
///
/// When created, the "publish" operation inherits the @ref doc_cc_mqtt311_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt311_client_publish_set_response_timeout() function.
/// @code
/// ec = cc_mqtt311_client_publish_set_response_timeout(publish, 1000);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt311_client_publish_get_response_timeout() function.
///
/// @subsection doc_cc_mqtt311_client_publish_resend Configuring "Publish" Re-Send Attempts
/// The MQTT v3.1.1 specification has a mechanism of insured delivery of the published
/// message to the broker. In the case of not 100% reliable connection the messages
/// can get lost and needs to be re-sent. The default amount of re-sends is @b 2, i.e.
/// when the first send is not acknowledged by the broker, it is tried again with
/// @b DUP flag is set in the @b PUBLISH message. When the second attempt is
/// not acknowledged, then the publish operation is terminated with appropriate
/// status report. It is possible to change the default by using
/// @b cc_mqtt311_client_publish_set_resend_attempts() function. The @b DUP flag
/// will be set in all the re-sent @b PUBLISH messages.
/// @code
/// ec = cc_mqtt311_client_publish_set_resend_attempts(publish, 3);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured resend attempts number use the @b cc_mqtt311_client_publish_get_resend_attempts() function.
///
/// @subsection doc_cc_mqtt311_client_publish_basic Configuration of "Publish" Operation
/// @code
/// CC_Mqtt311PublishConfig config;
///
/// // Assign default values to the "config"
/// cc_mqtt311_client_publish_init_config(&config);
///
/// // Update the required values
/// config.m_topic = "some/topic";
/// config.m_data = &some_buf[0];
/// config.m_dataLen = ...;
/// config.m_qos = ...;
///
/// // Perform the configuration
/// ec = cc_mqtt311_client_publish_config(publish, &config);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt311PublishConfig structure.
///
/// By default the library will perform the analysis of the submitted topic format and
/// reject it if topic format is incorrect. However, for performance reasons
/// it is possible to disable such verification when client application
/// ensures that no invalid topics are used.
/// @code
/// ec = cc_mqtt311_client_set_verify_outgoing_topic_enabled(client, false);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     ... /* Something is wrong */
/// }
/// @endcode
/// To retrieve the current configuration use the @b cc_mqtt311_client_get_verify_outgoing_topic_enabled()
/// function.
///
/// @b NOTE that the configuration is global per client and not per "publish"
/// operation.
///
/// Also @b note that the same function controls the verification of the
/// "subscribe", "unsubscribe", and "publish" filter / topic formats.
///
/// @subsection doc_cc_mqtt311_client_publish_send Sending Publish Request
/// When all the necessary configurations are performed for the allocated "publish"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt311_client_publish_send() function.
/// @code
/// void my_publish_complete_cb(void* data, CC_Mqtt311PublishHandle handle, CC_Mqtt311AsyncOpStatus status)
/// {
///     if (status != CC_Mqtt311AsyncOpStatus_Complete) {
///         printf("ERROR: The publish operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///     ...
/// }
///
/// ec = cc_mqtt311_client_publish_send(publish, &my_publish_complete_cb, data);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send publish request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "publish" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt311ErrorCode_Success.
///
/// The callback pointer can also be @b NULL. In such case the completion of the
/// publish operation is silent.
///
/// When QoS value is @ref CC_Mqtt311QoS_AtMostOnceDelivery, there
/// is no broker response to wait for and the callback is invoked right away
/// after sending the serialized data.
///
/// The handle returned by the @b cc_mqtt311_client_publish_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt311_client_publish_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt311ErrorCode_Success was returned).
/// The valid handle can be used to @ref doc_cc_mqtt311_client_publish_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// Note that the callback function receives the "publish" operation handle as
/// its second parameter. Although the handle is already invalid and cannot be
/// used in any other function, it allows the application to identify the
/// original "publish" request if multiple have been issued in parallel
/// and use the same callback function for all of them.
///
/// @subsection doc_cc_mqtt311_client_publish_cancel Cancel the "Publish" Operation.
/// While the handle returned by the @b cc_mqtt311_client_publish_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt311_client_publish_cancel(publish);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to cancel publish with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt311_client_publish_send() function was successfully
/// called before the @b cc_mqtt311_client_publish_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @subsection doc_cc_mqtt311_client_publish_order Message Ordering
/// The library implements strict message ordering for the @b same QoS messages
/// required by the MQTT v3.1.1 specification. However, when @b different QoS messages
/// are sent, the messages may arrive to the broker as well as recipient client
/// in different order. For example, if all the publishes below issued together in the specified order, the
/// @b Message2 and @b Message3 will probably arrive before @b Message1.
/// @li @b Message1 - QoS2
/// @li @b Message2 - Qos1
/// @li @b Message3 - QoS0
///
/// The library also provides an ability to force strict message ordering for
/// @b all values of QoS using the @b cc_mqtt311_client_publish_set_ordering() function.
/// @code
/// ec = cc_mqtt311_client_publish_set_ordering(client, CC_Mqtt311PublishOrdering_Full);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Publish ordering configuration failed with ec=%d\n", ec);
/// }
/// @endcode
/// The current configuration can be retrieved using @b cc_mqtt311_client_publish_get_ordering() function.
/// The @b default publish ordering is @ref CC_Mqtt311PublishOrdering_SameQos.
///
/// When a strict message ordering for @b all the messages is enabled (by setting @ref CC_Mqtt311PublishOrdering_Full),
/// The @b PUBLISH message is postponed if @b any of the statements below are true:
/// @li There are other postponed @b PUBLISH messages of previously issued "publish" operations.
/// @li There are previously issued and incomplete "publish" operation of @b higher QoS value.
///
/// The rules above allow sending the same as well as increasing QoS messages in parallel.
/// For example, if all the publishes below issued together in the specified order, the
/// @b Message11 and @b Message12 will be sent, while @b Message13 and @b Message14 are postponed
/// until the delivery of the @b Message12 is complete.
/// @li @b Message11 - QoS1
/// @li @b Message12 - Qos2
/// @li @b Message13 - QoS0
/// @li @b Message14 - QoS2
///
/// @subsection doc_cc_mqtt311_client_publish_simplify Simplifying the "Publish" Operation Preparation.
/// In many use cases the "publish" operation can be quite simple with a lot of defaults.
/// To simplify the sequence of the operation preparation and handling of errors,
/// the library provides wrapper function that can be used:
/// @li @b cc_mqtt311_client_publish()
///
/// For example:
/// @code
/// CC_Mqtt311PublishConfig config;
///
/// // Assign default values to the configuration
/// cc_mqtt311_client_publish_init_config(&config);
///
/// // Update values
/// config.m_topic = "some/topic";
/// config.m_data = ...;
/// ...
///
/// ec = cc_mqtt311_client_publish(client, &config, &my_publish_complete_cb, data);
/// if (ec != CC_Mqtt311ErrorCode_Success) {
///     printf("ERROR: Failed to send publish request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// Note that the wrapper function does NOT expose the handle returned by the
/// @b cc_mqtt311_client_publish_prepare(). It means that it's not possible to
/// cancel the "publish" operation before its completion or identify the
/// publish operation by the reported handle when the completion callback
/// is invoked.
///
/// @section doc_cc_mqtt311_client_receive Receiving Messages
/// Right after the successful "connect" operation, the library starts expecting
/// the arrival of the new messages and reports it via the @ref doc_cc_mqtt311_client_callbacks_message
/// "registered callback". <b>By default</b> the library monitors the topics the client
/// application @ref doc_cc_mqtt311_client_subscribe "subscribed" to and does not
/// report "rogue" messages from the broker.
///
/// @b Note that only topics themselves
/// are monitored, and not the requested maximal @b QoS values. It means that if
/// application requested maximal @b QoS1 for a particular subscription, but the
/// broker sends message using the @b QoS2, the message is still going to be
/// reported to the application.
///
/// However, if the broker is trusted to do the right thing, i.e. fully comply to
/// the specification, it is possible to enable / disable the incoming topics check using the
/// @b cc_mqtt311_client_set_verify_incoming_msg_subscribed() for performance reasons.
/// @code
/// CC_Mqtt311ErrorCode ec = cc_mqtt311_client_set_verify_incoming_msg_subscribed(client, false);
/// @endcode
/// To retrieve the current configuration use the @b cc_mqtt311_client_get_verify_incoming_msg_subscribed() function.
///
/// @b WARNING: When the incoming message subscription verification is disabled, the
/// library does @b NOT track any new @ref doc_cc_mqtt311_client_subscribe "subscription"
/// requests, which can result in dropping legit messages and not reporting them to the application
/// after the subscription verification is re-enabled later.
///
/// Similarly, the library also <b>by default</b> verifies the incoming topic format, that it doesn't contain
/// wildcard characters. To enable / disable such verification use the @b cc_mqtt311_client_set_verify_incoming_topic_enabled()
/// function.
/// @code
/// CC_Mqtt311ErrorCode ec = cc_mqtt311_client_set_verify_incoming_topic_enabled(client, false);
/// @endcode
/// To retrieve the current configuration use the @b cc_mqtt311_client_get_verify_incoming_topic_enabled() function.
///
/// To prioritize the in-order reception of the messages, the
/// @ref doc_cc_mqtt311_client_callbacks_message "message report callback" is invoked immediately on
/// reception of the QoS2 @b PUBLISH message. Just like it is shown as "Method B" in the "Figure 4.3" of the
/// MQTT v3.1.1 specification.
///
/// The @b QoS2 publish operation initiated by the broker requires exchange of multiple messages
/// between the broker and the client. When the library responds with the @b PUBREC
/// message, the broker is expected to send @b PUBREL back. The library uses the
/// @ref doc_cc_mqtt311_client_response_timeout configuration to measure the time frame
/// during which it allows the reception of the corresponding @b PUBREL message. If the latter doesn't
/// arrive in time, the inner state of the message reception gets discarded resulting in
/// the future rejection of the relevant @b PUBREL from the broker (if such arrives).
/// Depending on case whether the @b PUBREC message was actually received by the broker
/// and how the broker is implemented one of the following scenarios is possible:
/// @li The broker has NOT received the @b PUBREC and will resend its @b PUBLISH
///     resulting in the duplicate delivery of the message.
/// @li The broker has received the @b PUBREC and according to MQTT v3.1.1 specification
///     it is not allowed to perform @b PUBLISH again. Th broker might decide
///     to either drop its message delivery state (best case scenario) or
///     treat it as protocol error and disconnect the client.
///
/// With all said above it might be necessary to increase the @ref doc_cc_mqtt311_client_response_timeout
/// "response timeout" for slow networks.
///
/// @section doc_cc_mqtt311_client_unsolicited_disconnect Unsolicited Broker Disconnection
/// When broker disconnection is detected all the incomplete asynchronous operations
/// (except @ref doc_cc_mqtt311_client_publish "publish") will be terminated with the an appropriate
/// @ref CC_Mqtt311AsyncOpStatus "status" report. The incomplete @ref doc_cc_mqtt311_client_publish "publish"
/// operations will be preserved due to the following spec clause:
/// @code{.unparsed}
/// When a Client reconnects with CleanSession set to 0, both the Client and Server MUST re-send any
/// unacknowledged PUBLISH Packets (where QoS > 0) and PUBREL Packets using their original Packet
/// Identifiers [MQTT-4.4.0-1].
/// @endcode
///
/// The unsolicited broker disconnection can happen in one of the following scenarios:
///
/// @subsection doc_cc_mqtt311_client_unsolicited_disconnect_keep_alive Keep Alive Timeout
/// When there was no message from the broker for the "keep alive" timeout (configured during the @ref connect "connect"
/// operation) and the broker doesn't respond to the @b PING message.
/// In such case the library responds in the following way:
/// @li Terminates and invokes the callbacks of previously initiated but incomplete operations
///     (except @ref doc_cc_mqtt311_client_publish "publish") passing
///     the @ref CC_Mqtt311AsyncOpStatus_BrokerDisconnected as their status report.
/// @li Invokes the @ref doc_cc_mqtt311_client_callbacks_broker_disconnect "disconnection report callback"
///     registered using the @b cc_mqtt311_client_set_broker_disconnect_report_callback() function
///     reporting @ref CC_Mqtt311BrokerDisconnectReason_NoBrokerResponse as the disconnection reason.
///     without any disconnection information.
///
/// @subsection doc_cc_mqtt311_client_unsolicited_disconnect_protocol_error Detecting Protocol Error
/// In case the broker doesn't fully comply with the MQTT v3.1.1 specification or there is
/// some unexpected data corruption the library responds in the following way:
/// @li Terminates and invokes the callback of the operation that detected the protocol error with
///     the @ref CC_Mqtt311AsyncOpStatus_ProtocolError status report.
/// @li Terminates and invokes the callbacks of all other previously initiated but incomplete operations
///     (except @ref doc_cc_mqtt311_client_publish "publish") passing
///     the @ref CC_Mqtt311AsyncOpStatus_BrokerDisconnected as their status report.
/// @li Invokes the @ref doc_cc_mqtt311_client_callbacks_broker_disconnect "disconnection report callback"
///     registered using the @b cc_mqtt311_client_set_broker_disconnect_report_callback() function
///     reporting @ref CC_Mqtt311BrokerDisconnectReason_ProtocolError as the disconnection reason.
///     without any disconnection information.
///
/// With all said above it means that if application receives @ref CC_Mqtt311AsyncOpStatus_ProtocolError or
/// @ref CC_Mqtt311AsyncOpStatus_BrokerDisconnected status in the operation callback, then
/// the application is expected to wait for the @ref doc_cc_mqtt311_client_callbacks_broker_disconnect "disconnection report callback"
/// which will follow.
///
/// When the @ref doc_cc_mqtt311_client_callbacks_broker_disconnect "disconnection report callback" is called the application is
/// expected to go through the following steps:
/// @li Close network connection.
/// @li Re-establish network connection to the broker.
/// @li Perform the @ref doc_cc_mqtt311_client_connect "\"connect\"" operation from within a next event loop iteration.
///
///
/// In case the client re-connects to the broker and the broker reports "clean session",
/// then all the incomplete @ref doc_cc_mqtt311_client_publish "publish" operations
/// will be terminated with the @ref CC_Mqtt311AsyncOpStatus_Aborted status.
///
/// @section doc_cc_mqtt311_client_network_disconnect Network Disconnection
/// In addition to the @ref doc_cc_mqtt311_client_unsolicited_disconnect the network
/// connection can be suddenly terminated. Such
/// network disconnection is usually detected by the failing @b read or @b write
/// operations on I/O socket. When the application detects such network disconnection, it
/// is expected to report it to the library using @b cc_mqtt311_client_notify_network_disconnected()
/// function.
/// @code
/// // Report network disconnected
/// cc_mqtt311_client_notify_network_disconnected(client);
/// @endcode
/// When the network disconnection is reported, the similar workflow to one described
/// in the @ref doc_cc_mqtt311_client_unsolicited_disconnect section above is
/// performed, @b excluding the invocation of the
/// @ref doc_cc_mqtt311_client_callbacks_broker_disconnect "broker disconnection report callback".
/// When the incomplete operations get terminated the @ref CC_Mqtt311AsyncOpStatus_BrokerDisconnected status
/// is reported.
///
/// When the @ref doc_cc_mqtt311_client_unsolicited_disconnect is detected prior to
/// the detection of the network disconnection itself and the broker disconnection
/// report callback is invoked, there is <b>no need</b> to report the network disconnection
/// to the library.
///
/// Inquiry about current network disconnection status can be done using the
/// @b cc_mqtt311_client_is_network_disconnected() function.
/// @code
/// bool disconnected = cc_mqtt311_client_is_network_disconnected(client);
/// @endcode
/// Note that when the new "connect" op is @ref doc_cc_mqtt311_client_connect_prepare "prepared",
/// the library will assume that the network connection is re-established and
/// the subsequent call to the @b cc_mqtt311_client_is_network_disconnected() function
/// will return @b false.
///
/// @section doc_cc_mqtt311_client_thread_safety Thread Safety
/// In general the library is @b NOT thread safe. To support multi-threading the application
/// is expected to use appropriate locking mechanisms before calling relevant API functions.
/// However, if each thread operates on a separate allocated
/// @ref doc_cc_mqtt311_client_allocation "client", then the locking is required only
/// for the @ref doc_cc_mqtt311_client_allocation "client allocation logic".
///
/// @section doc_cc_mqtt311_client_debug_build Debug Build
/// The client library uses <a href="https://commschamp.github.io/comms_doc/page_use_prot.html#page_use_prot_error_handling">COMMS_ASSERT()</a>
/// macro to check some internal pre- and post-conditions. It is a bug if the assertion fails, please report if
/// encountered. By default it is like standard
/// <a href="https://en.cppreference.com/w/cpp/error/assert">assert()</a> but allows overriding
/// the default failure behavour, which can be more suitable for bare-metal systems. Please
/// refer to the <a href="https://commschamp.github.io/comms_doc/page_assert.html">documentation</a> for details.

